---
title: "Redes Sociales y Económicas"
author: Miquel Antoni Llambías Cabot
date: 11/28/2020
output: html_notebook
---

## Entrega 3

### 1. Implementar el cálculo de las matrices de los núcleos de Neumann. La función debería tener dos parámetros: la matriz de adyacencia y el grado de difusión.

Input: D: a p × p direct product matrix of two graphs
Output: γ: Decay constant

1. maxIndegree = `0`
1. maxOutdegree = `0`
1. foreach `vertex vi ∈ direct product matrix D` do
2. outdegree = `Pp j=1 Di,j`
2. indegree = `Pp j=1 Dj,i`
2. maxIndegree = `max(indegree, maxIndegree)`
2. maxOutdegree = `max(outdegree, maxOutdegree)`
2. end
1. Set `γ < 1/min(maxIndegree, maxOutdegree)`
1 return γ

```{r function DecayConstant}

DecayConstant <- function (A) {
  if(!is.matrix(A)) return("A must be a matrix")

  n <- length(A[1,])
  if(n != length(A[,1])) return("only sqare matrix allowed")

  maxIndegree <- 0
  maxOutdegree <- 0
  for(i in 1:n) {
    indegree <- 0
    outdegree <- 0
    for(j in 1:n) {
      indegree <- indegree + A[j,i]
      outdegree <- indegree + A[i,j]
    }
    maxIndegree <- max(indegree, maxIndegree)
    maxOutdegree <- max(outdegree, maxOutdegree)
  }

  return(1/min(maxIndegree, maxOutdegree))
}

```

Input: G—a directed graph representing a collection of items (e.g., web pages)
Output: `Kbγ` and `Tbγ`, Neumann Kernel matrices

1.  A ← adjacency matrix of `G`
1.  Compute `AT`
1.  K ← `ATA`
1.  T ← `AAT`
1.  Compute `∆+(G) and ∆−(G)`
1.  Choose γ between 0 and `1/(min{∆+(G),∆−(G)})`
1.  Compute Kbγ ← `K(I − γK)^−1`
1.  Compute Tbγ ← `T(I − γT)^−1`
1.  return `Kbγ`, `Tbγ`


Steps 5 and 6 are exchanged by the diffusionFactor

```{r function NeumannKernelMatrix}

NeumannKernelMatrix <- function (A, diffusionFactor) {
  if(!is.matrix(A)) {
    print("A must be a matrix")
    return(NULL)
  }
  n <- length(A[1,])
  if(n != length(A[,1])) {
    print("only sqare matrix allowed")
    return(NULL)
  }

  AT <- t(A)
  K <- AT %*% A
  T <- A %*% AT
  I <- diag(n)
  Kby <- K %*% solve(I - diffusionFactor*K)
  Tby <- T %*% solve(I - diffusionFactor*T)

  return(list("Kby"=as.matrix(Kby), "Tby"=as.matrix(Tby)))
}

```

### 2. Aplicar el algoritmo a la matriz de adyacencia de páginas webs: webPageLinks.txt. Responda, con estos datos, el ejercicio 6.7 del libro.

```{r load libraries}
#library(igraph)
```

```{r load data}
adjacency_matrix <- as.matrix(
        read.table("data/webPageLinks.txt", header=T, sep="	", row.names = 1))
```

```{r describe the graph}
#webPageLinks <- graph.adjacency(rawMatrix)
#is_connected(webPageLinks)
#plot(webPageLinks, vertex.label=NA)
```

```{r}
decayConstant <- DecayConstant(adjacency_matrix)
if(is.numeric(decayConstant)){
  print(paste("choose between 0 and", decayConstant, sep = " "))
} else {
  decayConstant
}
```

#### (a) Describe how the HITS algorithm relates to the Neumann Kernel technique.

```{r}
result <- NeumannKernelMatrix(adjacency_matrix, decayConstant) # fa de
```

```{r}
KbyGraph <- graph.adjacency(result$Kby)
plot(KbyGraph, vertex.label=NA) # LOL, no serveix o no ho se interpretar
components(KbyGraph)$no
```
```{r}
result <- NeumannKernelMatrix(adjacency_matrix, 0) # Choosing a value of γ = 0 results in the co-citation matrix
```

```{r}
KbyGraph <- graph.adjacency(result$Kby)
plot(KbyGraph, vertex.label=NA)
components(KbyGraph)$no
```

#### (b) How does the decay factor γ affect the output of the Neumann Kernel algorithm?


